% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match_params.R
\name{match_params}
\alias{match_params}
\title{Find matching node names}
\usage{
match_params(post, params, type = "base_index", auto_escape = TRUE)
}
\arguments{
\item{post}{an object of class \code{mcmc.list}}

\item{params}{a character vector with length >= 1. Passed to \code{stringr::str_detect},
so can, and sometimes should, be a regular expression; see the examples.
Duplicate matches found among different elements of \code{params} are discarded.}

\item{type}{a character vector with length == 1; only two options are accepted.
Set to \code{type = "base_only"} if you wish to return only the unique node names (without indices).
Set to \code{type = "base_index"} (the default) if you wish to return the node names with indices included.}

\item{auto_escape}{logical. \code{FALSE} will treat \code{"["} and \code{"]"}
as regular expression syntax (unless explicitly escaped by user),
\code{TRUE} will treat these symbols as plain text to be matched.
It is generally recommended to keep this as \code{TRUE} (the default),
unless you are performing complex regex searches that require the
\code{"["} and \code{"]"} symbols to be special characters}
}
\value{
a character vector with all node names that match \code{params}.
  If no matches are found, it will return an error with
  the base node names found the \code{mcmc.list} to help the next try.
}
\description{
Returns all the node names stored in an \code{mcmc.list} object
that match a provided string
}
\details{
this function is called as one of the first steps in many of the more downstream
  functions in this package. It is thus fairly important to get used to
  how the regular expressions work, particularly
  with the \code{\link[stringr]{str_detect}} function.
}
\examples{
# load example mcmc.list
data(cjs, package = "postpack")

# these produce same output b/c of regex pattern matching
match_params(cjs, params = c("b0", "b1"))
match_params(cjs, params = c("b"))

# force a match to start with B
match_params(cjs, "^B")

# force a match to end with 0
match_params(cjs, "0$")

# use a wild card to get b0[3] and b1[3]
match_params(cjs, "b.[3]")

# repeat a wild card
match_params(cjs, "s.+0")

# turn off auto escape to use [] in regex syntax rather than matching them as text
match_params(cjs, params = "[:digit:]$", auto_escape = F)

# pass an empty string to match all (same as get_params)
match_params(cjs, "")
}
