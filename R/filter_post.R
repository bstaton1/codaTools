#' Extract desired nodes from mcmc.list
#'
#' In many cases, it is helpful to perform operations on smaller subsets of a
#' \code{mcmc.list} object generated by a package like \code{jagsUI} or \code{coda}.
#' This function filters out a smaller subset corresponding only to the node requested.
#' It can be seen as one of the the "starting points" of the workflow of the functions in this package.
#'
#' @param post an object of class \code{mcmc.list} from which to filter out the node
#'   identified by \code{p}
#' @param p a character vector of with length >= 1. Passed to \code{stringr::str_detect()},
#'   so can (and perhaps should) be a regular expression.
#' @param matrix logical. If \code{TRUE}, the subsetted output will be returned as a matrix using
#'   \code{coda::as.matrix}. Defaults to \code{FALSE}, in which case the class \code{mcmc.list} will be retained.
#' @param iters logical. Do you wish to retain the iteration number if \code{matrix = TRUE}? Not used otherwise.
#'   Defaults to \code{FALSE}.
#' @param chains logical. Do you wish to retain the chain number if \code{matrix = TRUE}? Not used otherwise.
#'   Defaults to \code{FALSE}.
#'@export

filter_post = function(post, p = NULL, matrix = FALSE, iters = F, chains = F) {
  require(StatonMisc, quietly = T) # for %!in%

  # stop if post isn't mcmc.list
  if (!coda::is.mcmc.list(post)) {
    stop ("post must be an object of class 'mcmc.list'")
  }

  # stop if p wasn't supplied
  if (is.null(p)) {
    stop("No nodes supplied to extract. Please specify 'p', or see ?filter_post for details")
  }
  p = ifelse(!stringr::str_detect(p, "\\\\"), ins_regex_bracket(p), p)

  # extract all parameters in the post object
  all_p = get_nodes(post, type = "all")

  # extract the node names
  u_p = get_nodes(post, type = "unique")

  # determine which names match
  keep = unlist(lapply(p, function(x) {
    all_p[stringr::str_detect(all_p, x)]
  }))

  # the base name (no index)
  base = unique(stringr::str_replace(keep, "\\[.+\\]", ""))

  # stop if none were detected
  if (length(keep) == 0) stop(paste("no nodes detected with name like:", p, ".\n\n The unique nodes monitored were:\n\n  ", paste(u_p, collapse = ", "), sep = ""))

  # extract them from each chain and coerce to mcmc.list
  post_out = coda::as.mcmc.list(lapply(post, function(x) x[,keep]))

  # if reformatting to matrix type, do so
  if (matrix) {
    post_out = as.matrix(post_out, iters = iters, chains = chains)
  }

  # return the output
  return(post_out)
}
