#' Extract desired nodes from mcmc.list
#'
#' In many cases, it is helpful to perform operations on smaller subsets of a
#' \code{mcmc.list} object generated by a package like \code{jagsUI} or \code{coda}.
#' This function filters out a smaller subset corresponding only to the node requested.
#' It can be seen as one of the the "starting points" of the workflow of the functions in this package.
#'
#' @param post an object of class \code{mcmc.list} from which to filter out the node
#'   identified by \code{p}
#' @param p a character vector of with length >=. Passed to \code{stringr::str_detect()},
#'   so can (and perhaps should) be a regular expression.
#' @param format a character vector of length 1 specifying the desired output format.
#'   Currently accepted options are \code{format = "mcmc.list"} and \code{format = "matrix"}.
#'   Defaults to \code{format = "mcmc.list"}.
#' @param iters logical. Do you wish to retain the iteration number if \code{format = "mcmc.list"}?
#' @param chains logical. Do you wish to retain the chain number if \code{format = "mcmc.list"}?
#'
#'@export

filter_post = function(post, p = NULL, format = "mcmc.list", iters = F, chains = F) {
  require(StatonMisc) # for %!in%

  # stop if post isn't mcmc.list
  if (!coda::is.mcmc.list(post)) {
    stop ("post is not an object of class 'mcmc.list'!")
  }

  # stop if p wasn't supplied
  if (is.null(p)) {
    stop("No nodes supplied to extract. Please specify 'p', please see ?post_extract")
  }
  p = ifelse(!stringr::str_detect(p, "\\\\"), ins_regex_bracket(p), p)

  # stop if format isn't accepted
  if (format %!in% c("mcmc.list", "matrix")) {
    stop("format must be one of 'mcmc.list' or 'matrix'.")
  }

  # stop if used a special character
  # if (!stringr::str_detect(p, "\\\\[")) {
  #   stop("You must escape the special character '['.\n  Use '\\\\[' instead.")
  # }

  # extract all parameters in the post object
  all_p = colnames(post[[1]])

  # extract the node names
  u_p = get_nodes(post, type = "unique")

  # determine which names match
  keep = unlist(lapply(p, function(x) {
    all_p[stringr::str_detect(all_p, x)]
  }))

  # the base name (no index)
  base = unique(stringr::str_replace(keep, "\\[.+\\]", ""))

  # stop if none were detected
  if (length(keep) == 0) stop(paste("no nodes detected with name like:", p, ".\n\n The unique nodes monitored were:\n\n  ", paste(u_p, collapse = ", "), sep = ""))

  # extract them from each chain and coerce to mcmc.list
  post_out = coda::as.mcmc.list(lapply(post, function(x) x[,keep]))

  # if reformatting to matrix type, do so
  if (format == "matrix") {
    post_out = as.matrix(post_out, iters = iters, chains = chains)
  }

  # return the output
  return(post_out)
}
